import json, re, setuptools, shutil, types

from os import path
from hashlib import sha256
from distutils.core import Extension, setup as _distutils_setup
from distutils.command.build_ext import build_ext

here = path.abspath(path.dirname(__file__))

# read the contents of README file
with open(path.join(here, 'README.md')) as f:
    long_description = f.read()

# give an escaped representation of a `str`, `bytes` or `Iterable[int]` value
def c_str(s):
    out = '' # see https://w.wiki/34HP
    escape = {8: 98, 9: 116, 10: 110, 13: 114, 34: 34, 39: 39, 63: 63, 92: 92}
    if isinstance(s, str): s = map(ord, s)
    for n in s:
        if n in escape:   out += f'\\{escape[n]:c}'
        elif n <=   0x1f: out += f'\\{n:o}'
        elif n <=   0x7e: out += f'{n:c}'
        elif n <=   0xff: out += f'\\x{n:02x}'
        elif n <= 0xffff: out += f'\\u{n:04x}'
        else:             out += f'\\U{n:08x}'

    return f'"{out}"'

# generate functions to add constants to module from system header files
def make_constants(header, prefix, regex):
    warn = '/* XXX This file is automatically generated by setup.py! */'
    hfile = '/usr/include/' + header
    out = path.join(here, f'nflogconst{prefix}.cc')
    if path.isfile(hfile):
        # get checksum of header file
        with open(hfile, 'rb') as f:
            cksum = sha256(f.read()).hexdigest()

        # if checksum matches, don't regenerate
        if path.isfile(out):
            with open(out) as f:
                for line in f.readlines():
                    if cksum in line:
                        return None

        # generate lines of output file
        r = re.compile(regex)
        with open(hfile) as h:
            output = [
                warn,
                f'/* {cksum} */',
                '#include <Python.h>',
                f'#include <{header}>',
                '#include "nflogconst.h"',
                f'int nflog_add_{prefix}s(PyObject *m) {{',
                '  if (!m) { return -1; }'
            ]

            for line in h.readlines():
                m = r.match(line)
                if m:
                    (x, y, z) = (prefix.upper(), m.group(1), m.group(2))
                    output.append(f'  ADDINTCONST(m, "{x}_{y}", {z});')

            output.append('  return 0;\n}')

        # actually write output file
        with open(out, 'w') as f:
            f.writelines(map(lambda x: x+'\n', output))
    else:
        # fall back to pregenerated file if header can't be found
        with open(path.join(here, f'{prefix}_def.cc')) as i:
            with open(out, 'w') as o:
                o.write(warn+'\n')
                o.writelines(i.readlines())

make_constants('linux/if_arp.h', 'hwtype', r'.+ARPHRD_(\S+)\s+(\S+).*')
make_constants('linux/if_ether.h', 'proto', r'.+ETH_P_(\S+)\s+(\S+).*')

# wrapper around distutils.setup that injects some compiler arguments
def setup(**attrs):
    cmdclass = attrs.setdefault('cmdclass', {})
    _build_ext = cmdclass.get('build_ext', build_ext)
    class wrapped_build_ext(_build_ext):
        def run(self):
            prefix = re.sub('[^A-Z0-9_]', '_', attrs['name'].upper())
            # https://filippo.io/instance-monkey-patching-in-python/
            _build_extension = self.build_extension
            def build_extension(self, ext):
                if not isinstance(getattr(ext, 'extra_compile_args', 0), list):
                    setattr(ext, 'extra_compile_args', [])

                ext.extra_compile_args.extend([
                    f'-D{prefix}_DEBUG=' + str(self.debug or 0),
                    f'-D{prefix}_META=' + c_str(json.dumps({
                        '__build_debug__':  bool(self.debug),
                        '__title__':        attrs['name'],
                        '__description__':  attrs['description'],
                        '__url__':          attrs['url'],
                        '__version__':      attrs['version'],
                        '__author__':       attrs['author'],
                        '__author_email__': attrs['author_email'],
                        '__license__':      attrs['license'],
                    }, ensure_ascii=False, separators=(',', ':'))),
                ])

                _build_extension(ext)

            self.build_extension = types.MethodType(build_extension, self)
            build_ext.run(self)

    cmdclass['build_ext'] = wrapped_build_ext
    return _distutils_setup(**attrs)

setup(
    name="nflogr",
    version='0.2.0',
    description='An object-oriented Python interface to read data via NFLOG',
    long_description=long_description,
    long_description_content_type='text/markdown',
    author='Ryan Castellucci',
    author_email='pypi-b51f@ryanc.org',
    license='MIT',
    url='https://github.com/ryancdotorg/python-nflogr',
    ext_modules=[Extension(
        name="nflogr",
        sources=[
            "nflogr.cc", "nflog.cc", "nflogdata.cc", "nflogopt.cc",
            "nflogconstproto.cc", "nflogconsthwtype.cc",
        ],
        libraries=["netfilter_log", "nfnetlink"],
    )],
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'Intended Audience :: Information Technology',
        'Intended Audience :: System Administrators',
        'License :: OSI Approved :: MIT License',
        'Operating System :: POSIX :: Linux',
        'Programming Language :: C',
        'Programming Language :: C++',
        'Programming Language :: Python :: 3.6',
        'Topic :: Security',
        'Topic :: Communications',
        'Topic :: Internet :: Log Analysis',
        'Topic :: System :: Networking :: Monitoring'
    ],
    keywords='nflog linux',
    packages=setuptools.find_packages(),
    python_requires=">=3.6",
)
